---
title: "FARIMA-GARCH"
author: "DEBA"
date: "12/22/2024"
output: html_document
---

```{r}
library(arfima) 
library(quantmod)
library(forecast)
library(rugarch)
library(tseries)
library(openxlsx)
library(xts)
```


```{r}
# Étape 1 : Chargement des données et calcul des rendements
getSymbols("ADBE", from = "2010-01-01", to = "2024-10-31", src = "yahoo")
adobe_prices <- Cl(ADBE)
adobe_returns <- na.omit(diff(log(adobe_prices)))
```


```{r}
# Étape 2 : Analyse graphique

par(mfrow = c(2, 2))

plot(adobe_returns, main = "Rendements Logarithmiques d'Adobe", ylab = "Rendements", col = "blue")

acf(adobe_returns, main = "ACF des rendements")
pacf(adobe_returns, main = "PACF des rendements")

acf(adobe_returns**2, lag.max = 100, main = "ACF des carrés des rendements")

# Test de stationnarité avec ADF
adf_test <- adf.test(adobe_returns)
print(adf_test)
```




```{r}
# Étape 3 : Grid search pour le modèle FARIMA avec arfima
grid_search_farima <- function(data, max_p = 5, max_q = 3) {
  results <- list()  # Liste pour stocker les modèles
  
  for (p in 0:max_p) {
    for (q in 0:max_q) {
      tryCatch({
        # Ajustement du modèle FARIMA
        model <- arfima(data, order = c(p, 0, q))
        
        # Extraction du AIC
        aic <- AIC(model)
        
        # Vérification de la blancheur des résidus
        residuals <- residuals(model)$Mode1
        lb_pval <- Box.test(residuals, lag = 20, type = "Ljung-Box")$p.value
        
        # Stockage des résultats
        results <- append(results, list(data.frame(
          p = p,
          q = q,
          d = model$modes[[1]]$dfrac,
          aic = aic,
          LBox_pval = lb_pval
        )))
      }, error = function(e) { cat("Error with model p =", p, "q =", q, "\n") })
    }
  }
  
  # Convertir la liste de résultats en un data frame
  results_df <- do.call(rbind, results)
  
  # Tri des modèles par AIC croissant
  results_df <- results_df[order(results_df$aic), ]
  
  return(results_df)
}

```


```{r}

# Recherche des modèles
farima_results <- grid_search_farima(as.numeric(adobe_returns))

# Affichage des meilleurs résultats
farima_results
```


```{r}
# Étape 4 : Sélection du meilleur modèle et vérification des diagnostics
best_model <- arfima(data, order = c(3, 0, 2))

# Résumé du meilleur modèle
print(summary(best_model))
```


```{r}
# Vérification des résidus
best_residuals <- residuals(best_model)$Mode1

par(mfrow = c(2, 1))
acf(best_residuals, main = "ACF des Résidus du FARIMA")
pacf(best_residuals, main = "PACF des Résidus du FARIMA")
Box.test(best_residuals, lag = 20, type = "Ljung-Box")
```


## Étape 5 : Modèle GARCH sur les résidus FARIMA
```{r}
# Estimation des modèles GARCH(p, q) avec rugarch
grid_search_garch <- function(residuals, max_p = 2, max_q = 2) {
  results <- data.frame(p = integer(), q = integer(), aic = numeric(), lb_pval = numeric())
  
  for (p in 0:max_p) {
    for (q in 0:max_q) {
      tryCatch({
        spec <- ugarchspec(
          variance.model = list(model = "sGARCH", garchOrder = c(p, q)),
          mean.model = list(armaOrder = c(0, 0)),
          distribution.model = "norm"
        )
        fit <- ugarchfit(spec = spec, data = residuals)
        
        # Stockage des résultats
        aic <- infocriteria(fit)[1]
        lb_pval <- Box.test(residuals(fit), lag = 20, type = "Ljung-Box")$p.value
        results <- rbind(results, data.frame(p = p, q = q, aic = aic, lb_pval = lb_pval))
      }, error = function(e) {})
    }
  }
  
  results <- results[order(results$aic), ]
  return(results)
}

# Appel à la fonction
garch_results <- grid_search_garch(best_residuals)
print(garch_results)

```


```{r}
# Étape 5 : Modèle GARCH sur les résidus FARIMA
spec_garch <- ugarchspec(variance.model = list(model = "sGARCH", garchOrder = c(1, 1)),
                         mean.model = list(armaOrder = c(0, 0), include.mean = FALSE),
                         distribution.model = "std")  # Distribution t-student

garch_fit <- ugarchfit(spec = spec_garch, data = best_residuals)
```


```{r}
# Résultats du modèle GARCH
show(garch_fit)
```


```{r}
# Étape 6 : Vérification des résidus standardisés GARCH
garch_residuals <- residuals(garch_fit, standardize = TRUE)

par(mfrow = c(2, 1))
acf(garch_residuals, main = "ACF des Résidus Standardisés du GARCH")
pacf(garch_residuals, main = "PACF des Résidus Standardisés du GARCH")
Box.test(garch_residuals, lag = 20, type = "Ljung-Box")
#ArchTest(garch_residuals, lags = 20)
```


```{r}
# Étape 7 : Extraire la volatilité conditionnelle journalière
volatility_daily <- sigma(garch_fit)

# Vérification que les longueurs des données concordent
if (length(volatility_daily) == nrow(adobe_returns)) {
  adobe_returns$volatility <- xts(volatility_daily, order.by = index(adobe_returns))
} else {
  stop("Les longueurs des séries de volatilité et des rendements ne correspondent pas.")
}
```


```{r}
chart_Series(adobe_returns$volatility)
chart_Series(adobe_returns$ADBE.Close)

# Exporter en CSV avec les dates et la volatilité
 write.csv(data.frame(Date = index(adobe_returns), coredata(adobe_returns)), "adobe_returns_with_volatility.csv", row.names = FALSE)


```

